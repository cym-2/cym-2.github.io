---
title: python algorithm 1
author: CYM
date: 2021-01-30 22:00:00
categories: [python]
tags: [algorithm]
---

## Stack
<br>
<br>
특징: LIFO<br>
예시: 웹 브라우저 방문기록 (뒤로 가기) => 가장 나중에 열린 페이지부터 다시 보여줌.<br>
검색 시 복잡도: O(N)<br>
<br>

```
class Node:
    def __init__(self, item, next):
        self.item = item
        self.next = next
        
class Stack:
    def __init__(self):
        self.last = None
        
    def push(self, item):
        self.last = Node(item, self.last)
        
    def pop(self):
        item = self.last.item
        self.last = self.last.next
        return item
        
stack = Stack()

for i in range(1, 6):
    stack.push(i)
    
for _ in range(5):
    print(stack.pop())
    
```

<br>
<br>
<br>

---

<br>

## Queue
<br>
<br>
특징: FIFO<br>
예시: 프린터의 인쇄 대기열<br>
검색 시 복잡도: O(N)<br>
<br>

```
class Queue:
    def __init__(self):
        self.queue = []
        
    def push(self, x):
        self.queue.append(x)
        return None
        
    def pop(self):
        length = len(self.queue)
        if length < 1:
            print("Queue is empty!")
            return False
        result = self.queue[0]
        del self.queue[0]
        return result
        
    def empty(self):
        return not self.queue
        
queue = Queue()

for i in range(1, 6):
    queue.push(i)

for _ in range(5):
    print(queue.pop())
       
```

<br>
<br>
<br>

---

<br>

## 큐를 이용한 스택 구현
<br>
<br>

```
import collections

class MyStack:
    def __init__(self):
        self.q = collections.deque()
        
    def push(self, x):
        self.q.append(x)
        # 요소 삽입 후 맨 앞에 두는 상태로 재정렬
        for _ in range(len(self.q) - 1):
            self.q.append(self.q.popleft())
            
    def pop(self):
        return self.q.popleft()
        
    def top(self):
        return self.q[0]
        
    def empty(self):
        return len(self.q) == 0
```

<br>
<br>
<br>

---

<br>

## 스택을 이용한 큐 구현
<br>
<br>

```
class MyQueue:
    def __init__(self):
        self.input = []
        self.output = []
      
    def push(self, x):
        self.input.append(x)
        
    def pop(self):
        self.peek()
        return self.output.pop()
        
    def peek(self):
        # output이 없으면 모두 재입력
        if not self.output:
            while self.input:
                self.output.append(self.input.pop())
        return self.output[-1]
        
    def empty(self):
        return self.input == [] and self.output == []
```

<br>
<br>
<br>

---

<br>

## Binary Tree
<br>
<br>
자식노드가 최대 두 개인 노드들로 구성된 트리<br>
<br>
<br>
<br>

---

<br>

## Binary Search Tree
<br>
<br>
정렬된 트리를 말하는데,<br>
노드의 왼쪽 서브트리에는 그 노드의 값보다 작은 값들을 지닌 노드로 이뤄져있는 반면,<br>
노드의 오른쪽 서브트리에는 그 노드의 값과 같거나 큰 값들을 지닌 노드들로 이루어진 트리<br>
이렇게 왼쪽과 오른쪽의 값들이 각각 값의 크기에 따라 정렬되어 있는 트리.<br>
<br>
탐색 시 시간 복잡도: O(logN)<br>
최악의 경우: 선형으로 한쪽으로 쏠려있을때<br>
해결방법: AVL트리. Depth차이를 최소화<br>
<br>
<br>
<br>

---

<br>

## Binary Search
<br>
<br>
데이터가 정렬돼 있는 배열에서 특정한 값을 찾아내는 알고리즘.<br> 
배열의 중간에 있는 임의의 값을 선택하여 찾고자 하는 값 X와 비교.<br> 
X가 중간 값보다 작으면 중간 값을 기준으로 좌측의 데이터들을 대상으로,<br> 
X가 중간값보다 크면 배열의 우측을 대상으로 다시 탐색.<br>
동일한 방법으로 다시 중간의 값을 임의로 선택하고 비교.<br>
해당 값을 찾을 때까지 이 과정을 반복.<br>
<br>
탐색 시 시간 복잡도: O(logN)

```
# 정렬된 nums를 입력받아 이전 검색으로 target에 해당하는 인덱스 찾아라
# 입력: nums = [-1, 0, 3, 5, 9, 12], target = 9
# 출력: 4

def search(self, nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] < target:
            left = mid + 1
        elif nums[mid] > target:
            right = mind - 1
        else:
            return mid
    return -1
```

<br>
<br>
<br>

---

<br>

## Hashing
<br>
<br>
하나의 문자열을 원래의 것을 상징하는 더 짧은 길이의 값이나 키로 변환하는 것.<br> 
해싱은 해시 테이블(Hash Table)과 해시 함수(Hash Function)로 구성.<br>
<br>
충돌이 발생할 경우: 오픈 어드레싱: 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식.<br>
<br>
<br>
<br>

---

<br>

## Sorting
<br>
<br>

정렬 알고리즘은 목록의 요소를 특정 순서대로 넣는 알고리즘.<br> 
대개 숫자식 순서와 사전식 순서로 정렬.<br>
<br>

**1. 버블 정렬: O(N^2)**<br>

```
def bubblesort(A):
    for i in range(1, len(A)):
        for j in range(0, len(A) - 1):
            if A[j] > A[j + 1]:
                A[j], A[j + 1] = A[j + 1], A[j]
```

<br>

**2. 병합 정렬: O(NlogN)**<br>

```
def merge_sort(a):
    n = len(a)
    # 종료 조건: 정렬할 리스트의 자료 개수가 한 개 이하면 정렬할 필요 없음
    if n <= 1:
        return a
    # 그룹을 나누어 각각 병합 정렬을 호출하는 과정
    mid = n // 2 # 중간을 기준으로 두 그룹으로 나눔
    g1 = merge_sort(a[:mid]) # 재귀 호출로 첫 번째 그룹을 정렬
    g2 = merge_sort(a[mid:]) # 재귀 호출로 두 번째 그룸을 정렬
    # 두 그룹을 하나로 병합
    result = [] # 두 그룹을 합쳐 만들 최종 결과
    while g1 and g2: # 두 그룹에 모두 자료가 남아 있는 동안 반복
      if g1[0] < g2[0]: # 두 그룹의 맨 앞 자료 값을 비교
          # g1의 값이 더 작으면 그 값을 빼내어 결과로 추가
          result.append(g1.pop())
      else:
          # g2의 값이 더 작으면 그 값을 빼내어 결과로 추가
          result.append(g2.pop(0))
    # 아직 남아 있는 자료들을 결과에 추가
    # g1과 g2 중 이미 빈 것은 while을 바로 지나감
    while g1:
        result.append(g1.pop(0))
    while g2:
        result.append(g2.pop(0))
    return result

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
print(merge_sort(d))
```

<br>

**3. 퀵 정렬: O(N^2)**<br>

```
def quicksort(A, lo, hi):
    def partition(lo, hi):
        pivot = A[hi]
        left = lo
        for right in range(lo, hi):
            if A[right] < pivot:
                A[left], A[right] = A[right], A[left]
                left += 1
        A[left], A[hi] = A[hi], A[left]
        return left
    
    if lo < hi:
        pivot = partition(lo, hi)
        quicksort(A, lo, pivot - 1)
        quicksort(A, pivot + 1, hi)
```

<br>
<br>
<br>

---

<br>

## DFS(깊이 우선 탐색)

<br>
<br>

```
def recursive_dfs(v, discovered=[]):
    discovered.append(v)
    for w in graph[v]:
        if not w in discovered:
            discovered = recursive_dfs(w, discovered)
    return discovered
```

<br>
<br>
<br>

---

<br>

## BFS(너비 우선 탐색)

<br>
<br>

```
def iterative_bfs(start_v):
    discovered = [start_v]
    queue = [start_v]
    while queue:
        v = queue.pop(0)
        for w in graph[v]:
            if w not in discovered:
                discovered.append(w)
                queue.append(w)
    return discovered
```

<br>
<br>
<br>

---

<br>

## set과 list의 차이
<br>
<br>
list는 중복 허용, set은 허용하지 않음<br>
<br>
<br>
<br>

---

<br>

## call by value와 call by reference
<br>
<br>
Call by value(값에 의한 호출)<br>
장점 : 복사하여 처리하기 때문에 안전하다. 원래의 값이 보존 됨.<br>
단점 : 복사를 하기 때문에 메모리가 사용량이 늘어남.<br>
<br>
Call by reference(참조에 의한 호출)<br>
장점 : 복사하지 않고 직접 참조를 하기에 빠름.<br>
단점 : 직접 참조를 하기에 원래 값이 영향을 받음.(리스크)<br>
<br>
<br>
<br>

---

<br>

## DP
<br>
<br>
다이나믹 프로그래밍 알고리즘은 문제를 각각의 작은 문제로 나누어 해결한 결과를 저장해뒀다가<br> 
나중에 큰 문제의 결과와 합하여 풀이하는 알고리즘.<br>
<br>

```
def fib(self, N: int) -> int:
    x, y = 0, 1
    for i in range(0, N):
        x, y = y, x + y
    return x
``` 

<br>
<br>
<br>

---

<br>

## ArrayList와 LinkedList의 차이
<br>
<br>

ArrayList는 데이터들이 순서대로 쭉 늘어선 배열의 형식을 취하고 있는 반면 <br>
LinkedList는 순서대로 늘어선 것이 아니라 자료의 주소 값으로 서로 연결되어 있는 구조.<br>
어레이는 랜덤 억세스가 가능하고 리스트는 리니어하게 접근해들어가야하기 때문에 차이 발생.<br>
<br>
<br>
<br>

---

<br>

## Heap
<br>
<br>

```
class BinaryHeap(object):
    def __init__(self):
        self.items = [None]
        
    def __len__(self):
        return len(self.items) - 1
        
    # 삽입 시 실행, 반복 구조 구현
    def _percolate_up(self):
        i = len(self)
        parent = i // 2
        while parent > 0:
            if self.items[i] < self.items[parent]:
                self.items[parent], self.items[i] = self.items[i], self.items[parent]
            i = parent
            parent = i // 2
    
    def insert(sellf, k):
        self.items.append(k)
        self._percolate_up()
        
    # 추출시 실행, 재귀 구조 구현
    def _percloate_down(self, idx):
        left = idx * 2
        right = idx * 2 + 1
        smallest = idx
        
        if left <= len(self) and self.items[left] < self.items[smallest]:
            smallest = left
        
        if right <= len(self) and self.items[right] < self.items[smallest]:
            smallest = right
        
        if smallest != idx:
            self.items[idx], self.items[smallest] = self.items[smallest], self.items[idx]
            self._percolate_down(smallest)
            
    def extract(self):
        extracted = self.items[1]
        self.items[1] = self.items[len(self)]
        self.items.pop()
        self._percolate_down(1)
        return extracted
```
